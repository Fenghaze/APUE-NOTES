# 实例：多进程版并发服务器

父进程负责接受连接，创建多个子进程来处理每个连接

子进程处理数据

> ./parrlel/server.c



# ==并发服务器：IO多路转接==

**详见【01.IO操作/高级IO】**

IO多路转接：实现文件描述符的监视，当文件描述符状态发生改变时，再执行相应的操作

并发服务器是接受多个客户端的请求，对每个客户端的socket进行操作

**socket的本质是文件描述符，所以可以使用多路转接来监视多个客户端的socket变化**

（服务器委托内核调用相关函数，来监听多个socket）

==实现步骤：==

- 1、布置监视任务
- 2、选择监视函数对socket进行监视（select、poll、==epoll==）
- 3、根据监视的结果来执行相应的操作



# ==线程池：生产者消费者模型==

常用在服务端处理数据

当服务端接收到多个客户端发送来的数据时，需要对每个客户端的数据进行单独处理，会用到线程池

--------------------------------------------------------------------------------------------------------------------------------------------

线程池：一堆已经启动了的线程

- 静态线程池：能创建的线程有固定数量
- 动态线程池：有下限和上限，会因为客户端的数量在这个区间内动态扩张/缩减（定义步长）
  - 什么时候扩张/缩减？单独用一个线程来管理
  - 定义两个变量：当前存活的线程数、当前运行的线程数；根据比例来进行扩张/缩减



服务端维护着一个**任务队列**，当有客户端发送数据给服务端时，服务端相当于接到了一个任务，将这个客户端fd放入到任务队列中，然后让线程池中的所有线程来抢这个任务进行处理



任务队列是临界资源，需要互斥锁

任务队列的情况：

- 任务队列为空：线程池等待阻塞（直到任务队列有任务才开始取任务）
- 任务队列满：服务端等待阻塞（直到任务队列不满才开始接收客户端的新任务）



> 【示例】：./thread_pool/pool.c



# 开源库

常见的开源库：libevent、libev（libevent的升级版，增加了线程）



## 开源库的一般使用方式

查看README

- 执行`./configure`：检查当前主机环境是否适合安装，自动生成makefile
- 执行`make`：编译
- 执行`sudo make install`
- simple目录是例子
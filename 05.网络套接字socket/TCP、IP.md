# 协议

规定了通信双方**数据传输的格式和方法**，双方交换数据（通信）的规则



# 1 TCP/IP协议分层

OSI参考模型（自底向上）：**物数网传会表应**

物理层、数据链路层；网络层；传输层；会话层、表示层、应用层



TCP/IP模型（自底向上）：

- 链路层：ARP映射，以太网帧
- ==网络层==：提供点到点的服务；IP协议，ICMP协议，IGMP协议
  - ping调用了ICMP
- ==传输层==：提供端到端的服务；TCP协议、UDP协议
- 应用层：应用程序的端口号



# 2 封装与分用

操作系统做的事：

发送端：将数据按照分层模型自顶向下的协议进行打包

接收端：将数据按照分层模型自底向上的协议进行解包

![](./assets/封装过程.png)

**发送端自顶向下进行封装**：

应用程序【发送的数据】→TCP【应用程序】→IP【TCP【应用程序】】→以太网数据帧【IP【TCP【应用程序】】】

**打包**：网络接口层（链路层）协议（网络层协议（传输层协议==（应用层协议（数据==

对于操作系统而言，对数据进行打包时也有用户的参与（其中应用层协议的封装是在User态完成的），外面三层协议的封装是在Kernel态完成的

应用层协议：如HTTP协议



**接收端自底向上进行分用**

**拆包**：因为数据是要打包之后才能在网络中传输的，且数据受到多个层协议的影响，不可能将数据一次性打包，因此需要对数据进行拆包传输

如：

数据60000kb，经过多层封装后，最外层的网络接口层的协议（以太网帧）允许传输最大字节数为1500

因此需要将数据进行拆分，拆成60000/1500=40个包进行封装再传输



# 3 端口号

服务器提供的端口号是固定的，给客户端提供服务，一般低于1024，如http（80），https（443），ftp（20，21）

客户端的端口号是短暂随机的，一般为1024-5000



# ==4 链路层==：以太网帧和IEEE 802.3封装

相同点：

- 两种帧格式都采用48bit（6字节）的目的地址和源地址

## 以太网帧

以太网帧是链路层封装的协议

数据包是依据MAC地址（MAC地址唯一）来进行传输的

**数据报最小46个字节，低于46需要填充；最大1500字节，高于1500需要分片（分包）**

1500是取传输路径上的**最小MTU**

```shell
目的MAC地址（6）|源MAC地址（6）|帧类型（2）|数据（46-1500）|CRC（4）

不同类型的以太网帧发送的数据类型如下：
类型0800（2）|IP数据报（46-1500）
类型0806（2）|ARP请求/应答（28）+PAD填充字段（18）
类型0835（2）|RPAP请求/应答（28）+PAD填充字段（18）
```

![](./assets/以太网帧.png)

目的地址：下一跳的MAC（网卡）地址，一开始不知道，需要发送ARP广播来获得

源地址：当前的MAC地址

==帧类型==：0800（发送普通数据）、0806（发送ARP请求，获取下一个节点的MAC地址）



## ==ARP：找到下一跳地址==

广播（发送端请求下一跳地址）：向所有路由发送ARP广播，寻找下一跳路由的MAC地址

单播（接收端应答下一跳地址）：向发送ARP广播的主机回应自己的MAC地址



**ARP 数据报**

![](./assets/ARP.png)

```
目的MAC（6）|源MAC（6）|帧类型（2）硬件类型（2）协议类型（2）|...|发送端MAC|发送端IP（4）|目的MAC|目的IP
```

作用：获取下一跳的MAC地址



数据包在网络传输的过程中会经过一个一个的路由节点，是如何找到到达目的地所需要经过的路由节点？

实际上，数据包不是只打包一次解包一次的

数据包想要达到下一个路由节点（下一跳）时，一开始是不知道这个路由器的MAC地址的

因此需要对**链路层和网络层进行解包**

网络层解包：获得了==源IP地址==和最终要到达的==目的地IP地址==

链路层解包：获得了==当前MAC地址==，目的MAC全为FF（不知道目的MAC是多少）

于是再将==源IP地址==、==当前MAC地址==和==目的地IP==打包起来，**作为以太网帧的数据**，并向路由表中的所有路由器发送一个ARP广播请求

匹配的下一跳路由器接收到ARP请求，将自己的MAC地址进行补充，然后又按照自身的路由表发送一个ARP单播请求

此时发送端接收到这个ARP请求，获得了下一个路由节点的MAC地址后，就可以将这个MAC地址填充到以太网帧中，进行正常的网络传输

**简单来说，发送端到接收端中途会经过许多路由器，每要到达下一个路由器，都需要对数据包的链路层和网络层进行一次解包，从而获得下一个路由器的MAC地址，再将数据包发送给这个路由器，以此类推，最终到达接收端**



==注意！！！==

- ==以太网帧和ARP数据报中的源MAC和目的MAC是指当前的MAC和下一跳的MAC，它们负责找到传输路径==
- ==真正的目的地IP是封装在网络层的IP协议中的==
- **通俗理解：**
  - 对帧当中的IP地址的理解：发货人、收货人（始终不变）
  - 对帧当中的MAC地址的理解：
    - 源MAC：货物中途所经过的上一个驿站
    - 目标MAC：货物中途所要到达的下一个驿站



# ==5 网络层==：IP协议

IP提供不可靠、无连接、无序的数据报传送服务

**不可靠是指：不能保证IP数据报能够成功到达目的地，中途可能会因为网络延时或阻塞造成数据报丢失**

![](./assets/IP首部.png)

总长度100字节=IP首部（20）+选项（40）+数据（40）

- 前32位：==网络字节序（大端字节序）==，IP数据报传输时必须统一网络字节序
- 16位标识：标识主机发送的每一份数据报
- 3位标志：SYN, FIN, ...
- 8位生存时间：数据报可以经过的最多路由器数量，通常为64或128，经过一个路由器TTL值减1；当TTL=0时，数据报丢弃，并发送ICMP报文通知源主机
- 8位协议：协议号，如
- 选项：记录传输过程中的路由记录



> IP数据报分析

![](./assets/IP数据报.png)

**十进制转换为16位二进制**

4 5 0 —>01000101 00000000
28 —>00000000 00011100
1 —>00000000 00000001
00 —>00000000 00000000
4 17 —>00000100 00010001
10.12.14.5 —>00001010 00001100 00001100 00000110
12.6.7.9 —> 00001110 00000101 0000111 00001001



**每16位二进制转换为4个十六进制**

4 5 0 —>4500（0100=4,	0101=5,	0000=0,	0000=0）
28 ---->001C（0000=0，	0000=0，	0001=1，	1100=12=C）
1 --------->0001
0 0 —>0000
4 17 ---->0411
10.12.14.5 —> 0A0C 0E05
12.6.7.9 -->0C06 0709



## IP路由选择

IP路由选择是逐跳进行的，只为IP数据报提供下一跳路由器的IP地址

### 路由表

IP层在内存中有一个路由表，路由表包含以下信息：

- 目的IP地址
- 当前IP的下一跳路由器的IP地址，或者直连的网络IP地址
- 标志
- 为数据报的传输指定一个网络接口

### 路由选择步骤

- 搜索路由表，寻找能与目的IP地址完全匹配的路由表，如果找到，就把数据报发送给路由表中指定的下一跳路由器或直连的网络IP地址
- 搜索路由表，寻找能与目的网络号相匹配的路由表，后续步骤同上
- 搜索路由表，寻找标为“默认（default）”的路由表（默认是下一跳地址），后续步骤同上

如果上述都不能成功，数据报就不能被发送，返回“主机不可达”、“网络不可达”的错误



## ICMP协议

协议号：1

ICMP是IP的附属协议，是一种功能协议，是在IP数据报内部传输的，**封装在IP数据报内部**

主要功能：

- 确认IP包是否成功送达目标地址
- 通知在发送过程中IP包被废弃的具体原因
- 改善网络设置

**作用：**测试网络，确认网络是否正常工作，遇到异常时进行问题诊断

![](./assets/ICMP.png)

```
8位类型|8位代码|16位校验和
（不同类型和代码有不同的内容）
```

常见类型代码：

- 8 0：请求回显（ping请求），查询报文
- 0 0：回显应答（ping应答），查询报文
- 3 x：不可达，差错报文
- 5 x：重定向，差错报文
- 11 x：超时，差错报文



# 6 ==传输层==：UDP协议

UDP是不可靠传输协议

UDP封装![](./assets/udp.png)

UDP首部![](./assets/udp首部.png)

端口号：表示发送进程和接收进程





# 6 ==传输层==：TCP协议

特点：

- 应答机制：发送端发送的每个TCP报文段都必须得到接收方的应答才认为数据传输成功
- 超时重传机制：发送方发出一个TCP报文段后启动定时器，在定时器内未收到应答，重发
- 数据重组：TCP报文由IP协议封装，IP数据报在网络层进行传输，到达接收端时可能乱序、重复，接收端收到时，TCP协议会对数据报进行重排、整理再传给应用层



TCP封装![](./assets/tcp封装.png)

TCP首部![](./assets/tcp.png)





## TCP状态转换图

查看TCP状态命令：`netstat -apn | gerp 端口号`

主动方状态：

- SYN_SENT：SYN发送并等待ACK回应

- ESTABLISHED：连接建立成功
- FIN_WAIT1：第一次挥手，主动方发起关闭（close）请求，发送FIN给被动方

- FIN_WAIT2：第二次挥手，接收到被动方回应ACK，此时处于半关闭状态

- TIME_WAIT：等待被动方发送的FIN，回应ACK，并等待2MSL再全关闭（在等待时间内，端口还没关闭）

被动方状态：

- LISTEN：监听
- SYN_RCVD：接收主动方的SYN，并回应ACK
- ESTABLISHED：连接建立成功
- CLOSE_WAIT：前两次挥手，接收FIN，并回应ACK
- LAST_ACK：主动close，发送FIN给主动方，等待ACK
- CLOSED：关闭连接



![](D:/mynotes/APUE-NOTES/05.网络套接字socket/TCP状态转换图.png)



![](D:/mynotes/APUE-NOTES/05.网络套接字socket/TCP状态转换图2.png)

## 心跳包

作用：用于检测客户端和服务器之间是否仍然保持连接

服务器和客户端之间有一个心跳包（应用层实现）：**固定的频率**来发送标志位，类似网络层的协议

乒乓包：类似于心跳包，但是可以携带简单数据



# 网络层与传输层的关系

网络层与硬件联系紧密，网络传输会不稳定

传输层：对网络层进行弥补

- 完全不弥补UDP：无连接不可靠报文传输
- 完全弥补TCP：面向连接的可靠数据包传输




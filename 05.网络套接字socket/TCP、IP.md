# 0 什么是协议？

规定了通信双方**数据传输的格式和方法**，双方交换数据（通信）的规则



# 1 TCP/IP协议分层

OSI参考模型（自底向上）：**物数网传会表应**

物理层、数据链路层；网络层；传输层；会话层、表示层、应用层

 

TCP/IP模型（自底向上）：**链网传应**

- 链路层：ARP映射，以太网帧
- ==网络层==：提供==点到点==的服务；IP协议，ICMP协议，IGMP协议
- ==传输层==：提供==端到端==的服务； TCP协议、UDP协议
- 应用层：应用程序的端口号



# 2 封装与分用

## 2.1 封装

操作系统做的事：

发送端：将数据按照分层模型自顶向下的协议进行封装（打包）

![](./assets/封装过程.png)

**发送端自顶向下进行封装**：

应用程序【发送的数据】→TCP【应用程序】→IP【TCP【应用程序】】→以太网数据帧【IP【TCP【应用程序】】】

**打包**：网络接口层（链路层）协议（网络层协议（传输层协议==（应用层协议（数据==

对于操作系统而言，对数据进行打包时也有用户的参与（其中应用层协议的封装是在User态完成的），外面三层协议的封装是在Kernel态完成的

应用层协议：如HTTP协议

—————————————————————————————————————————

应用层的数据在发送到物理网络之前，将沿着协议栈从上往下依次传递，每层协议都将在上层数据的基础上进行封装
自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装

> TCP报文封装：
>
> 当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务进行网络传输。
>
> 传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。

<img src="./TCP封装过程.png" style="zoom:67%;" />

> UDP报文封装：
>
> UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。
>
> 当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。





## 2.2 分用

接收端：将数据按照分层模型自底向上的协议进行分用（解包）

因为数据是要打包之后才能在网络中传输的，且数据受到多个层协议的影响，不可能将数据一次性打包，因此需要对数据进行拆包传输

如：

数据60000kb，经过多层封装后，最外层的网络接口层的协议（以太网帧）允许传输最大字节数为1500

因此需要将数据进行拆分，拆成60000/1500=40个包进行封装再传输



链路层：以太网帧MTU=1500字节；Internet的MTU=576字节

IP协议中数据报长度最大为65535个字节，但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报（或分片）的长度都远远没有达到最大值，==IP数据报数据部分最多为1480字节==（IP头部占用20字节，1480=1500-20）

UDP协议封装在IP数据报中，UDP首部为8字节，因此UDP数据报最多为1480-8=1472字节

TCP首部为20字节，TCP数据报最多为1480-20=1460字节



# ==3 链路层==

**数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。**

以太网帧和IEEE 802.3链路层封装的协议，相同点：

- 两种帧格式都采用48bit（6字节）的目的地址和源地址

## 3.1 以太网帧

==以太网帧是最终在物理网络上传送的字节序列==

在链路层，数据包是依据MAC地址（MAC地址唯一）来进行传输的

MTU（Max  Transmit  Unit）：帧的最大传输单元，即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限制。

**数据报最小46个字节，低于46需要填充；最大1500字节，高于1500需要分片（分包）**

1500是取传输路径上的**最小MTU**

```shell
目的MAC地址（6）|源MAC地址（6）|帧类型（2）|数据（46-1500）|CRC（4）

不同类型的以太网帧发送的数据类型如下：
类型0800（2）|IP数据报（46-1500）
类型0806（2）|ARP请求/应答（28）+PAD填充字段（18）
类型0835（2）|RPAP请求/应答（28）+PAD填充字段（18）
```

![](./assets/以太网帧.png)

目的地址：下一跳的MAC（网卡）地址，一开始不知道，需要发送ARP广播来获得

源地址：当前的MAC地址

==帧类型==：0800（发送普通数据）、0806（发送ARP请求，获取下一个节点的MAC地址）



## 3.2 地址解析协议（ARP）协议：找到下一跳地址

广播（发送端请求下一跳地址）：向所有路由发送ARP广播，寻找下一跳路由的MAC地址

单播（接收端应答下一跳地址）：向发送ARP广播的主机回应自己的MAC地址

**ARP 数据报**

![](./assets/ARP.png)

```
目的MAC（6）|源MAC（6）|帧类型（2）硬件类型（2）协议类型（2）|...|发送端MAC|发送端IP（4）|目的MAC|目的IP
```

作用：获取下一跳的MAC地址



数据包在网络传输的过程中会经过一个一个的路由节点，是如何找到到达目的地所需要经过的路由节点？

实际上，数据包不是只打包一次解包一次的

数据包想要达到下一个路由节点（下一跳）时，一开始是不知道这个路由器的MAC地址的

因此需要对**链路层和网络层进行解包**

网络层解包：获得了==源IP地址==和最终要到达的==目的地IP地址==

链路层解包：获得了==当前MAC地址==，目的MAC全为FF（不知道目的MAC是多少）

于是再将==源IP地址==、==当前MAC地址==和==目的地IP==打包起来，**作为ARP的数据报**，并向路由表中的所有路由器发送一个ARP广播请求

匹配的下一跳路由器接收到ARP请求，将自己的MAC地址进行补充，然后又按照自身的路由表发送一个ARP单播请求

此时发送端接收到这个ARP请求，获得了下一个路由节点的MAC地址后，就可以将这个MAC地址填充到以太网帧中，进行正常的网络传输

**简单来说，发送端到接收端中途会经过许多路由器，每要到达下一个路由器，都需要对数据包的链路层和网络层进行一次解包，发送ARP广播进行匹配，从而获得下一个路由器的MAC地址，再发送ARP单播，回应数据报给这个路由器，以此类推，最终到达接收端**



==注意！！！==

- ==以太网帧和ARP数据报中的源MAC和目的MAC是指当前的MAC和下一跳的MAC，它们负责找到传输路径==
- ==真正的目的地IP是封装在网络层的IP协议中的==
- **通俗理解：**
  - 对帧当中的IP地址的理解：发货人、收货人（始终不变）
  - 对帧当中的MAC地址的理解：
    - 源MAC：货物中途所经过的上一个驿站
    - 目标MAC：货物中途所要到达的下一个驿站

在Linux中，可使用`tcpdump`命令来观察ARP通信过程

## 3.3 ARP高速缓存

ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物
理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度

在Linux中，可使用`arp`命令来查看和修改ARP高速缓存



# ==4 网络层==

**网络层实现数据包的选路和转发。**通信的两台主机之间一般不是直接相连的，中间包含多个路由器节点，网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。

## 4.1 IP协议

**核心协议：IP协议**，根据数据包的目的IP地址来决定如何投递它。

**IP提供不可靠、无连接、无状态无序的数据报传送服务**

无状态、无序的：

- 指IP==通信双方不同步==传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是==相互独立、没有上下文关系==的
- 优点：简单、高效
- 缺点：无法处理乱序和重复的IP数据报，需要上层协议(TCP协议)进行进一步处理

不可靠的：

- 不能保证数据报能够成功到达目的地，中途可能会因为网络延时或阻塞造成数据报丢失
- 需要上层协议，如TCP协议实现数据确认、超时重传等机制达到可靠传输

无连接：

- 指IP通信双方都==不长久地维持==对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对方的IP地址

![](./assets/IP首部.png)

IP首部（20字节+选项40字节）

- 4位版本：==IP协议版本==，如4（IPV4）
- 4位首部长度：该IP头部有多少个32 bit（4字节）
- 8位服务类型：主要包含4位TOS字段（**最小延时、最大吞吐量、最高可靠性和最小费用**）
- 16位总长度：指**整个IP数据报的长度**，以字节为单位，因此IP数据报的最大长度为65535（$2^{16}-1$）字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报（或分片）的长度都远远没有达到最大值。接下来的3个字段则描述了如何实现分片

- 前32位：==网络字节序（大端字节序）==，IP数据报传输时必须**统一网络字节序**
- 16位标识：标识主机发送的每一份数据报。其**初始值由系统随机生成**；每发送一个数据报，其值就加1。该值在数据报分片时被==复制==到每个分片中，因此==同一个数据报的所有分片都具有相同的标识值==。
- 3位标志：第一位保留；第二位（DF，禁止分片）；第三位（MF，更多分片）
- 13位片偏移：是分片相对原始IP数据报开始处（仅指数据部分）的偏移
- 8位生存时间：数据报可以经过的最多路由器数量，通常为64或128，经过一个路由器TTL值减1；当TTL=0时，数据报丢弃，并发送ICMP报文通知源主机；TTL值可以**防止数据报陷入路由循环**
- 8位协议：==传输层的协议号==，如TCP(6), UDP(17)，ICMP（1）
- 选项：记录传输过程中的路由记录
  - 记录路由：告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，就可以跟踪数据报的传递路径
  - 时间戳：告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间
  - 松散源路由选择：指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器
  - 严格源路由选择：数据报只能经过被指定的路由器



> IP数据报分析

![](./assets/IP数据报.png)

**十进制转换为16位二进制**

4 5 0 —>01000101 00000000
28 —>00000000 00011100
1 —>00000000 00000001
00 —>00000000 00000000
4 17 —>00000100 00010001
10.12.14.5 —>00001010 00001100 00001100 00000110
12.6.7.9 —> 00001110 00000101 0000111 00001001



**每16位二进制转换为4个十六进制**

4 5 0 —>4500（0100=4,	0101=5,	0000=0,	0000=0）
28 ---->001C（0000=0，	0000=0，	0001=1，	1100=12=C）
1 --------->0001
0 0 —>0000
4 17 ---->0411
10.12.14.5 —> 0A0C 0E05
12.6.7.9 -->0C06 0709



## 4.2 IP分片

- 分片时间：可能发生在发送端、中转路由器上，而且可能在传输途中进行多次分片

- 分片组装：在最后目标机器的内核IP模块进行重新组装

- 如何分片：IP头部三个字段（16位标识、3位标志、13位片偏移）提供了分片和组装信息，假设一个数据报被分片为N份子数据报：
  - 具有相同的16位标识
  - 除了最后一个分片外，其他分片的3位标志设置为MF
  - 具有不同的13位片偏移
  - IP头部的16位总长度设置为该分片的总长度
- 以太网帧和IP：以太网帧的MTU是1500字节，则封装的==IP数据报数据部分最多为1480字节==（IP头部占用20字节）



## 4.3 IP路由

**IP路由选择是逐跳进行的，只为IP数据报提供下一跳路由器的IP地址**

**IP数据报应该发送至哪个下一跳路由（或者目标机器），以及经过哪个网卡来发送，就是IP路由过程**



### 4.3.1 IP模块工作流程

![](./IP模块工作流程.png)

- 情况一：如果IP数据报的选项中==设置了路由选择==或==IP数据报不是发送给本机==：调用**转发子模块**来处理
- 情况二：如果IP数据报的==目标IP是本机的IP==或==广播地址==：将该IP数据报**派发给本机的上层应用（分用）**



### 4.3.2 路由表

IP层在内存中有一个路由表，路由表主要包含以下信息：

- 目的IP地址、网关地址、网络掩码
- 路由标志
- 路由距离
- 该路由项对应的输出网卡接口



### 4.3.3 路由选择步骤

- （1）搜索路由表，寻找能与数据报目的IP地址完全匹配的==主机IP==，如果找到，就使用该路由项，否则执行步骤（2）；
- （2）搜索路由表，寻找能与目的==网络号相匹配的IP地址==，如果找到，就使用该路由项，否则执行步骤（3）；
- （3）搜索路由表，寻找标为“默认（default）”的路由项（通常执行到这一步时下一跳路由是==网关==）

如果上述都不能成功，数据报就不能被发送，返回“主机不可达”、“网络不可达”的错误



### 4.3.4 IP转发

IP模块的数据报转发子模块中，对于情况一，执行如下操作：

- 1）检查数据报头部的TTL值。如果TTL值已经是0，则丢弃该数据报
- 2）查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。
- 3）如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由
- 4）将TTL值减1
- 5）处理IP头部选项
- 6）如果有必要，则执行IP分片操作



## 4.4 ICMP协议

协议号：1

ICMP是IP的附属协议，是一种功能协议，是在IP数据报内部传输的，**封装在IP数据报内部**

主要功能：

- 确认IP包是否成功送达目标地址
- 通知在发送过程中IP包被废弃的具体原因
- 改善网络设置

**作用：**==测试网络，确认网络是否正常工作==，遇到异常时进行问题诊断

![](./assets/ICMP.png)

ICMP报文分为两大类：==差错报文==和==查询报文==，常见类型、代码如下：

- 8 0：请求回显（ping请求），查询报文
- 0 0：回显应答（ping应答），查询报文
- 3 x：不可达，差错报文
- 5 x：重定向，差错报文
- 11 x：超时，差错报文



# 5 网络层与传输层的关系

网络层与硬件联系紧密，网络传输会不稳定（IP协议不可靠）

传输层：对网络层进行弥补

- 完全不弥补UDP：无连接不可靠报文传输
- 完全弥补TCP：面向连接的可靠数据包传输



# 6 ==传输层==

**传输层为两台主机上的应用程序提供端到端的通信。**传输层只关心通信的==起始端==和==目的端==，而不在乎数据包的中转过程，负责数据的收发、链路的超时重连等

## 6.1 端口号

服务器提供的端口号是固定的知名端口号，给客户端提供服务，一般低于1024，如http（80），https（443），ftp（20，21）

客户端的端口号是短暂随机的临时端口号，一般为1024-5000



## 6.2 用户数据报（UDP）协议

**UDP为应用层提供不可靠、无连接和基于数据报的服务**

**不可靠的：**

- UDP协议无法保证数据从发送端正确地传送到目的端
- 如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败
- 使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑

**无连接的：**

- 通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）

**基于数据报的：**

- 相对基于字节流的服务而言，==每个UDP数据报都有一个长度==，接收端必须以该长度为最小单位将其所有内容==一次性==读出，否则数据将被截断
- 通信双方必须执行==相同次数==的读、写
- 发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送
- 接收端必须**及时**针对每一个UDP数据报执行读操作（`recvfrom`系统调用），否则就会丢包；如果没有**足够大的临时缓冲区**来读取UDP数据，则UDP数据报就会被截断

UDP封装![](./assets/udp.png)

UDP首部![](./assets/udp首部.png)

端口号：表示发送进程和接收进程



## ==6.2 传输控制（TCP）协议==

**TCP为应用层提供可靠的、面向连接的、基于字节流的服务**

**可靠的：**

- 应答机制：发送端发送的每个TCP报文段都必须得到接收方的应答才认为数据传输成功
- 超时重传机制：发送方发出一个TCP报文段后启动定时器，在定时器内未收到应答，重发
- 数据重组：TCP报文由IP协议封装，IP数据报在网络层进行传输，到达接收端时可能乱序、重复，接收端收到时，TCP协议会对数据报进行重排、整理再传给应用层

**面向连接的（全双工）：**

- 使用TCP协议==通信的双方必须先建立TCP连接==，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等
- 当通信结束时，双方必须关闭连接以释放这些内核数据

**基于字节流的：**

- 基于流的数据==没有边界（长度）限制==，它源源不断地从通信的一端流入另一端
- 发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出
- 发送端应用程序执行多次**写操作**，TCP模块将这些数据放入TCP**发送缓冲区**，当TCP模块真正发送数据时，发送缓冲区就将这些待发送的数据封装成一个或多个TCP报文段发出。**程序的写操作数和发送的TCP报文段数量没有关系**
- 同理，接收端的读操作数和**接收缓冲区**的报文段数量也没有关系



TCP封装![](./assets/tcp封装.png)

TCP首部![](./assets/tcp.png)

- 16位端口号：点对点通信，需要源端口号和目的端口号
- ==32位序列号（seq）：==
  - 每次通信，**序列号为对方发送的确认号**，==用于确认收到对方的报文==
  - TCP三次握手建立连接中：通信双方的序列号是一个随机值（ 为0）
- ==32位确认号（ack）：用于对另一方发送来的TCP报文的响应==,告诉对方我收到了你发送的数据
  - **对方发送的序列号+标志位长度+对方发送的数据长度**（三次握手过程中没有数据传输，标志位长度为1）
  - 数据长度的作用是：当收到数据报后知道收到了多少个数据，从而==确认数据报是否完整==
- 4位首部长度：标识TCP头部有多少个32位字（4字节）
- 6位标志位：URG（紧急指针是否有效），**ACK（确认报文段）**，PSH（接收端应立即读取TCP接收缓冲区数据），RST（对方重新建立连接，复位报文段），**SYN（同步报文段）**，**FIN（结束报文段）**
- ==16位窗口大小==：用于TCP流量控制。窗口是指接收通告窗口（RWND），告诉本端TCP==接收缓冲区==还能容纳多少字节，这样发送端就可以控制发送速度
- 16位校验：由发送端填充，可靠传输的保障
- 16位紧急指针：一个正的偏移量。紧急指针+序列号=最后一个紧急数据的下一字节的序列号。用于发送端发送紧急数据

==注：牢记序列号和确认号的关系==

### 6.2.1 TCP 三次握手

![](./三次握手.png)

### 6.2.2 TCP 四次挥手

![](./四次挥手.png)

### 6.2.3 TCP状态转换图

查看TCP状态命令：`netstat -apn | gerp 端口号`

主动方状态：

- CLOSED->SYN_SENT：调用`connect()`主动建立连接，发送SYN
- SYN_SENT->ESTABLISHED：第二次握手，接收发送的ACK、SYN，连接建立成功
- ESTABLISHED->FIN_WAIT1：应用层调用close()请求关闭连接，发送FIN
- FIN_WAIT1->FIN_WAIT2：接收ACK，此时处于==半关闭状态==
- FIN_WAIT2->TIME_WAIT：接收FIN，发送ACK，并等待2MSL再全关闭（在等待时间内，==端口还没关闭==）
- FIN_WAIT1->CLOSING：第一次挥手等待被动方回应ACK，同时完成了三、四次挥手，处于正在关闭状态
- FIN_WAIT1->TIME_WAIT：接收FIN、ACK，发送ACK
- CLOSING->TIME_WAIT：接收ACK

==TIME_WAIT==：会等待2MSL时间（TCP报文最大生存时间是MSL）确保通信双方未被接收的、迟到的TCP报文已经消失。下一次建立安全连接时，可能会等待2MSL等待端口完全关闭才可使用，因此可以通过socket选项`SO_REUSERADDR`来强制取消延时等待。

被动方状态：

- CLOSED->LISTEN：应用层调用`listen()`，被动监听客户请求
- LISTEN->SYN_RCVD：接收主动方的SYN，并回应ACK
- SYN_RCVD->ESTABLISHED：连接建立成功
- ESTABLISHED->CLOSE_WAIT：前两次挥手，接收FIN，并回应ACK
- CLOSE_WAIT->LAST_ACK：第三次挥手，主动close，发送FIN给主动方，等待ACK
- LAST_ACK->CLOSED：关闭连接



![](./TCP状态转换图.png)



![](./TCP状态转换图2.png)

### 6.2.4 心跳包

作用：用于检测客户端和服务器之间是否仍然保持连接

服务器和客户端之间有一个心跳包（应用层实现）：**固定的频率**来发送标志位，类似网络层的协议

乒乓包：类似于心跳包，但是可以携带简单数据



### 6.2.5 TCP携带的数据

TCP报文段携带的应用数据按长度分为两种：交互数据和成块数据

- 交互数据包含很少的字节，使用交互数据的应用程序或协议对实时性要求较高，如telnet、ssh

- 成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序（或协议）对传输效率要求高，比如ftp



### 6.2.6 带外数据

传输层协议具有带外（Out Of Band，OOB）数据的概念，用于迅速通告对方，本端发生的**重要事件**，相比普通数据有更高的优先级，总是==立即被发送==，不论发送缓冲区是否有排队等待发送的普通数据。

传输方式：

- 方式一：TCP默认接收方式。TCP报文中设置URG（紧急指针）标志

- 方式二：TCP连接设置`SO_OOBINLINE`，将带外数据和普通数据一起存放在TCP接收缓冲区，再使用系统调用识别带外数据



# 7 应用层

**应用层负责处理应用程序的逻辑**

常见的应用层协议如下：

- ping：实质上是应用程序，利用ICMP报文检测网络连接，用于调试网络环境
- telnet：远程登录协议
- OSPF（Open Shortest Path First）：开放最短路径优先协议，是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息
- DNS（Domain Name Service）：域名服务协议，提供机器域名到IP地址的转换 
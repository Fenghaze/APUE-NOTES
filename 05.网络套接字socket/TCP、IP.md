# 0 什么是协议？

规定了通信双方**数据传输的格式和方法**，双方交换数据（通信）的规则



# 1 TCP/IP协议分层

OSI参考模型（自底向上）：**物数网传会表应**

物理层、数据链路层；网络层；传输层；会话层、表示层、应用层

 

TCP/IP模型（自底向上）：**链网传应**

- 链路层：ARP映射，以太网帧
- ==网络层==：提供==点到点==的服务；IP协议，ICMP协议，IGMP协议
- ==传输层==：提供==端到端==的服务； TCP协议、UDP协议
- 应用层：应用程序的端口号



# 2 封装与分用

## 2.1 封装

操作系统做的事：

发送端：将数据按照分层模型自顶向下的协议进行封装（打包）

![](./assets/封装过程.png)

**发送端自顶向下进行封装**：

应用程序【发送的数据】→TCP【应用程序】→IP【TCP【应用程序】】→以太网数据帧【IP【TCP【应用程序】】】

**打包**：网络接口层（链路层）协议（网络层协议（传输层协议==（应用层协议（数据==

对于操作系统而言，对数据进行打包时也有用户的参与（其中应用层协议的封装是在User态完成的），外面三层协议的封装是在Kernel态完成的

应用层协议：如HTTP协议

—————————————————————————————————————————

应用层的数据在发送到物理网络之前，将沿着协议栈从上往下依次传递，每层协议都将在上层数据的基础上进行封装
自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装

> TCP报文封装：
>
> 当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务进行网络传输。
>
> 传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。



> UDP报文封装：
>
> UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。
>
> 当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。

<img src="D:\C++\APUE-NOTES\05.网络套接字socket\TCP封装过程.png" style="zoom:67%;" />



==**拆包**==：因为数据是要打包之后才能在网络中传输的，且数据受到多个层协议的影响，不可能将数据一次性打包，因此需要对数据进行拆包传输

如：

数据60000kb，经过多层封装后，最外层的网络接口层的协议（以太网帧）允许传输最大字节数为1500

因此需要将数据进行拆分，拆成60000/1500=40个包进行封装再传输

## 2.2 分用

接收端：将数据按照分层模型自底向上的协议进行分用（解包）



# 3 端口号

服务器提供的端口号是固定的，给客户端提供服务，一般低于1024，如http（80），https（443），ftp（20，21）

客户端的端口号是短暂随机的，一般为1024-5000



# ==4 链路层==

**数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。**

以太网帧和IEEE 802.3链路层封装的协议，相同点：

- 两种帧格式都采用48bit（6字节）的目的地址和源地址

## 4.1 以太网帧

==以太网帧是最终在物理网络上传送的字节序列==

在链路层，数据包是依据MAC地址（MAC地址唯一）来进行传输的

MTU（Max  Transmit  Unit）：帧的最大传输单元，即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限制。

**数据报最小46个字节，低于46需要填充；最大1500字节，高于1500需要分片（分包）**

1500是取传输路径上的**最小MTU**

```shell
目的MAC地址（6）|源MAC地址（6）|帧类型（2）|数据（46-1500）|CRC（4）

不同类型的以太网帧发送的数据类型如下：
类型0800（2）|IP数据报（46-1500）
类型0806（2）|ARP请求/应答（28）+PAD填充字段（18）
类型0835（2）|RPAP请求/应答（28）+PAD填充字段（18）
```

![](./assets/以太网帧.png)

目的地址：下一跳的MAC（网卡）地址，一开始不知道，需要发送ARP广播来获得

源地址：当前的MAC地址

==帧类型==：0800（发送普通数据）、0806（发送ARP请求，获取下一个节点的MAC地址）



## 4.2 地址解析协议（ARP）协议：找到下一跳地址

广播（发送端请求下一跳地址）：向所有路由发送ARP广播，寻找下一跳路由的MAC地址

单播（接收端应答下一跳地址）：向发送ARP广播的主机回应自己的MAC地址

**ARP 数据报**

![](./assets/ARP.png)

```
目的MAC（6）|源MAC（6）|帧类型（2）硬件类型（2）协议类型（2）|...|发送端MAC|发送端IP（4）|目的MAC|目的IP
```

作用：获取下一跳的MAC地址



数据包在网络传输的过程中会经过一个一个的路由节点，是如何找到到达目的地所需要经过的路由节点？

实际上，数据包不是只打包一次解包一次的

数据包想要达到下一个路由节点（下一跳）时，一开始是不知道这个路由器的MAC地址的

因此需要对**链路层和网络层进行解包**

网络层解包：获得了==源IP地址==和最终要到达的==目的地IP地址==

链路层解包：获得了==当前MAC地址==，目的MAC全为FF（不知道目的MAC是多少）

于是再将==源IP地址==、==当前MAC地址==和==目的地IP==打包起来，**作为ARP的数据报**，并向路由表中的所有路由器发送一个ARP广播请求

匹配的下一跳路由器接收到ARP请求，将自己的MAC地址进行补充，然后又按照自身的路由表发送一个ARP单播请求

此时发送端接收到这个ARP请求，获得了下一个路由节点的MAC地址后，就可以将这个MAC地址填充到以太网帧中，进行正常的网络传输

**简单来说，发送端到接收端中途会经过许多路由器，每要到达下一个路由器，都需要对数据包的链路层和网络层进行一次解包，发送ARP广播进行匹配，从而获得下一个路由器的MAC地址，再发送ARP单播，回应数据报给这个路由器，以此类推，最终到达接收端**



==注意！！！==

- ==以太网帧和ARP数据报中的源MAC和目的MAC是指当前的MAC和下一跳的MAC，它们负责找到传输路径==
- ==真正的目的地IP是封装在网络层的IP协议中的==
- **通俗理解：**
  - 对帧当中的IP地址的理解：发货人、收货人（始终不变）
  - 对帧当中的MAC地址的理解：
    - 源MAC：货物中途所经过的上一个驿站
    - 目标MAC：货物中途所要到达的下一个驿站

在Linux中，可使用`tcpdump`命令来观察ARP通信过程

## 4.3 ARP高速缓存

ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物
理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度

在Linux中，可使用`arp`命令来查看和修改ARP高速缓存



# ==5 网络层==

**网络层实现数据包的选路和转发。**通信的两台主机之间一般不是直接相连的，中间包含多个路由器节点，网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。

## 5.1 IP协议

**核心协议：IP协议**，根据数据包的目的IP地址来决定如何投递它。

IP提供不可靠、无连接、无序的数据报传送服务

**不可靠是指：不能保证数据报能够成功到达目的地，中途可能会因为网络延时或阻塞造成数据报丢失**

![](./assets/IP首部.png)

总长度100字节=IP首部（20）+选项（40）+数据（40）

- 前32位：==网络字节序（大端字节序）==，IP数据报传输时必须**统一网络字节序**
- 16位标识：标识主机发送的每一份数据报
- 3位标志：SYN, FIN, ...
- 8位生存时间：数据报可以经过的最多路由器数量，通常为64或128，经过一个路由器TTL值减1；当TTL=0时，数据报丢弃，并发送ICMP报文通知源主机
- 8位协议：传输的协议号，如TCP(6), UDP(17)
- 选项：记录传输过程中的路由记录



> IP数据报分析

![](./assets/IP数据报.png)

**十进制转换为16位二进制**

4 5 0 —>01000101 00000000
28 —>00000000 00011100
1 —>00000000 00000001
00 —>00000000 00000000
4 17 —>00000100 00010001
10.12.14.5 —>00001010 00001100 00001100 00000110
12.6.7.9 —> 00001110 00000101 0000111 00001001



**每16位二进制转换为4个十六进制**

4 5 0 —>4500（0100=4,	0101=5,	0000=0,	0000=0）
28 ---->001C（0000=0，	0000=0，	0001=1，	1100=12=C）
1 --------->0001
0 0 —>0000
4 17 ---->0411
10.12.14.5 —> 0A0C 0E05
12.6.7.9 -->0C06 0709



## 5.2 IP路由选择

IP路由选择是逐跳进行的，只为IP数据报提供下一跳路由器的IP地址

### 5.2.1 路由表

IP层在内存中有一个路由表，路由表包含以下信息：

- 目的IP地址
- 当前IP的下一跳路由器的IP地址，或者直连的网络IP地址
- 标志
- 为数据报的传输指定一个网络接口

### 5.2.2 路由选择步骤

- 搜索路由表，寻找能与目的IP地址完全匹配的路由表，如果找到，就把数据报发送给路由表中指定的下一跳路由器或直连的网络IP地址
- 搜索路由表，寻找能与目的网络号相匹配的路由表，后续步骤同上
- 搜索路由表，寻找标为“默认（default）”的路由表（默认是下一跳地址），后续步骤同上

如果上述都不能成功，数据报就不能被发送，返回“主机不可达”、“网络不可达”的错误



## 5.3 ICMP协议

协议号：1

ICMP是IP的附属协议，是一种功能协议，是在IP数据报内部传输的，**封装在IP数据报内部**

主要功能：

- 确认IP包是否成功送达目标地址
- 通知在发送过程中IP包被废弃的具体原因
- 改善网络设置

**作用：**==测试网络，确认网络是否正常工作==，遇到异常时进行问题诊断

![](./assets/ICMP.png)

ICMP报文分为两大类：==差错报文==和==查询报文==，常见类型、代码如下：

- 8 0：请求回显（ping请求），查询报文
- 0 0：回显应答（ping应答），查询报文
- 3 x：不可达，差错报文
- 5 x：重定向，差错报文
- 11 x：超时，差错报文



# 6 ==传输层==

**传输层为两台主机上的应用程序提供端到端的通信。**传输层只关心通信的==起始端==和==目的端==，而不在乎数据包的中转过程，负责数据的收发、链路的超时重连等

## 6.1 用户数据报（UDP）协议

**UDP为应用层提供不可靠、无连接和基于数据报的服务**

**不可靠的：**

- UDP协议无法保证数据从发送端正确地传送到目的端
- 如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败
- 使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑

**无连接的：**

- 通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）

**基于数据报的：**

- 相对基于流的服务而言，==每个UDP数据报都有一个长度==，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断

UDP封装![](./assets/udp.png)

UDP首部![](./assets/udp首部.png)

端口号：表示发送进程和接收进程

## 6.2 传输控制（TCP）协议

**TCP为应用层提供可靠的、面向连接的、基于流的服务**

**可靠的：**

- 应答机制：发送端发送的每个TCP报文段都必须得到接收方的应答才认为数据传输成功
- 超时重传机制：发送方发出一个TCP报文段后启动定时器，在定时器内未收到应答，重发
- 数据重组：TCP报文由IP协议封装，IP数据报在网络层进行传输，到达接收端时可能乱序、重复，接收端收到时，TCP协议会对数据报进行重排、整理再传给应用层

**面向连接的：**

- 使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等
- 当通信结束时，双方必须关闭连接以释放这些内核数据

**基于流的：**

- 基于流的数据==没有边界（长度）限制==，它源源不断地从通信的一端流入另一端
- 发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出



TCP封装![](./assets/tcp封装.png)

TCP首部![](./assets/tcp.png)





## 6.3 TCP状态转换图

查看TCP状态命令：`netstat -apn | gerp 端口号`

主动方状态：

- SYN_SENT：SYN发送并等待ACK回应

- ESTABLISHED：连接建立成功
- FIN_WAIT1：第一次挥手，主动方发起关闭（close）请求，发送FIN给被动方

- FIN_WAIT2：第二次挥手，接收到被动方回应ACK，此时处于半关闭状态

- TIME_WAIT：等待被动方发送的FIN，回应ACK，并等待2MSL再全关闭（在等待时间内，端口还没关闭）

被动方状态：

- LISTEN：监听
- SYN_RCVD：接收主动方的SYN，并回应ACK
- ESTABLISHED：连接建立成功
- CLOSE_WAIT：前两次挥手，接收FIN，并回应ACK
- LAST_ACK：主动close，发送FIN给主动方，等待ACK
- CLOSED：关闭连接



![](./TCP状态转换图.png)



![](./TCP状态转换图2.png)

## 6.4 心跳包

作用：用于检测客户端和服务器之间是否仍然保持连接

服务器和客户端之间有一个心跳包（应用层实现）：**固定的频率**来发送标志位，类似网络层的协议

乒乓包：类似于心跳包，但是可以携带简单数据



# 7 网络层与传输层的关系

网络层与硬件联系紧密，网络传输会不稳定

传输层：对网络层进行弥补

- 完全不弥补UDP：无连接不可靠报文传输
- 完全弥补TCP：面向连接的可靠数据包传输



# 8 应用层

**应用层负责处理应用程序的逻辑**

常见的应用层协议如下：

- ping：实质上是应用程序，利用ICMP报文检测网络连接，用于调试网络环境
- telnet：远程登录协议
- OSPF（Open Shortest Path First）：开放最短路径优先协议，是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息
- DNS（Domain Name Service）：域名服务协议，提供机器域名到IP地址的转换
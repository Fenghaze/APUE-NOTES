<h1><center>并发-线程</center></h1>

# 1 线程的概念

一个进程至少有一个线程（如main函数），可以有多个线程

线程的本质：==一个正在运行的函数==

多个线程间是兄弟关系，多个线程存在一个进程中，内存空间共享

==一个进程可以创建的线程个数也是有限的==



线程有多个不同标准（是一套标准，而不是实现），常用的是POSIX线程、OPENMP线程

线程类型（线程标识）：pthread_t，p（指POSIX标准）



常用命令：

- `ps axm`：查看进程的详细信息，`- -`表示一个线程

- `ps ax -L`：以Linux关系查看进程和线程的关系，在Liunx中，是以PID来标识线程的（线程占用PID）



```c
#include <pthread.h>

// 比较两个线程ID是否相同
int pthread_equal(pthread_t t1, pthread_t t2);

// 获取当前线程的线程标识
pthread_t phread_self(void);
```



# 2 线程的操作

## 2.1 线程的创建

```c
// 创建一个线程标识存放在 thread 中
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
```

- thread：存放线程标识
- attr：指定线程属性，为NULL为默认属性
- 第三个参数：另一个线程的地址（函数地址）
- arg：函数要传入的参数列表

如果成功，返回0；否则返回errno



> 示例：在main线程中创建一个func线程 create1.c

```c
#include<stdlib.h>
#include<stdio.h>
#include<pthread.h>
#include<string.h>
static void *func(void *p) // func线程
{
    puts("Thread is working...");
    pthread_exit(NULL);
}
int main()	//main线程
{
    pthread_t tid;
    puts("Begin!");

    int err = pthread_create(&tid, NULL, func, NULL); // 创建一个func线程
    if(err)
    {
        fprintf(stderr, "%s\n", strerror(err));
        exit(1);
    }
    puts("End!");
    exit(0);
}
```



==线程的调度取决于调度器的调度策略==



## 2.2 线程的终止、收尸

有三种方式：

- 线程从启动例程返回，返回值是线程的退出码
- 线程被同一进程的其他线程取消
- 在当前线程调用`pthread_exit()`函数

如果被终止的线程是进程中最后一个线程，进程也将终止



```c
// 线程终止
void pthread_exit(void *retval);	// 类似进程中的exit()

// 线程收尸
int pthread_join(pthread_t thread, void **retval);	// 类似进程中的wait()
```



## 2.3 栈的清理

类似钩子函数

```c
void pthread_cleanup_push(void (*routine)(void *), void *arg);

void pthread_cleanup_pop(int execute); //使用了push之后，一定要调用pop
execute=0，表示不调用
execute=1，表示调用
```



## 2.4 线程的取消选项

一个线程在执行过程中，一定会用到线程取消

取消有两种状态：允许和不允许

允许取消分为：异步取消、推迟取消（默认，推迟是指推迟到**cancel点**）

cancel点：POSIX定义的cancel点，都是可能引发阻塞的系统调用

```c
// 线程取消
int pthread_cancel(pthread_t thread);

// 设置cancel状态：是否允许被取消
int pthread_setcancelstate(int state, int *oldstate);

// 设置允许取消的方式：异步取消、推迟取消
int pthread_setcanceltype(int type, int *oldtype);

// 设置一个取消点
void pthread_testcancel(void);
```



## 2.5 线程分离

```c
// 分离一个线程，分离后，该线程的生死存亡不关心
int pthread_detach(pthread_t thread);
```



# 3 线程同步

## 3.1 线程资源竞争

线程的调度是由调度器的调度策略决定的

多个线程共享进程的内存空间，当同一进程的多个线程都对同一个变量进行操作时，必然存在竞争关系

因此，需要解决这类冲突



## 3.2 互斥量

当出现资源竞争的情况时，希望对于某资源在任意时刻，只能有一个线程使用（上锁），当线程使用后，再解锁

互斥量就可以完成这个操作

```c
pthread_mutex_init();
pthread_mutex_destory();

pthread_mutex_lock();
pthread_mutex_trylock();
pthread_mutex_unlock();
```







# 4 线程属性

## 线程同步的属性



# 重入

# 线程与信号

# 线程与fork
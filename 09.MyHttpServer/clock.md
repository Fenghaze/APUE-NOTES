# 升序链表

如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含指向下一个定时器的指针成员。

进一步，如果链表是双向的，则每个定时器还需要包含指向前一个定时器的指针成员。

升序定时器链表：将其中的定时器按照超时时间做升序排序

 * 添加定时器的时间复杂度是O(n)
 * 删除定时器的时间复杂度是O(1)
 * 执行定时任务的时间复杂度是O(1)



# 时间轮

![](\assets\QQ截图20210524182237.png)

时间轮使用==哈希表==的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响

时间轮中有N个**槽（slot）**，以恒定的速度顺时针转动，每转动一步就指向下一个槽，每次转动称为一个**滴答（tick）**，一个滴答的时间称为时间轮的**槽间隔si（slot interval）**，这就是心博时间

时间轮转动一周所需时间为$N*si$

每个槽指向一条定时器链表，每条链表具有相同特征：定时时间相差 $N*si$ 的整数倍

时间轮正是利用这个关系**将定时器散列到不同的链表中**。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时器，则该定时器将被插入槽ts（timer slot）对应的链表中：$ts = (cs + (ti/si)) \bmod N$

对时间轮而言，要提高定时精度，就要使si值足够小；要提高执行(插入定时器)效率，则要求N值足够大

复杂的时间轮可能有多个轮子，不同的轮子拥有不同的粒度。相邻的两个轮子，精度高的转一圈，精度低的仅往前移动一槽，就像水表一样。

- 添加一个定时器的时间复杂度是O（1）

- 删除一个定时器的时间复杂度也是O（1）

- 执行一个定时器的时间复杂度是O（n）

  但实际上执行一个定时器任务的效率要比O（n）好得多，因为时间轮将所有的定时器散列到了不同的链表上。时间轮的槽越多，等价于散列表的入口（entry）越多，从而每条链表上的定时器数量越少。此外，我们的代码仅使用了一个时间轮。

  当使用多个轮子来实现时间轮时，执行一个定时器任务的时间复杂度将接近O（1）



# 时间堆

升序链表和时间轮都是以固定的频率调用心搏函数tick，并在其中依次检测到期的定时器，然后执行到期定时器上的回调函数

时间堆则是使用==最小堆排序==思想。将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器。

然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。

- 添加一个定时器的时间复杂度是O（Logn）
- 删除一个定时器的时间复杂度是O（1）
- 执行一个定时器的时间复杂度是O（1）
# Linux中使用的红黑树

红黑树（rbtree）：平衡二叉树，平衡的是黑色节点的高度

红黑树的特点：

- （a）key/value，实现**快速查找**
- （b）rbtree的顺序，来**查找一段数据**

红黑树的应用：

- epoll
- socket管理
- 文件系统
- 定时器
- 进程的调度
- 内存管理
- map映射



# Linux内核中如何使用红黑树

内核提供如下功能：

- 进程管理（CPU调度）
- 内存管理功能
- 文件系统管理（IO操作）
- 硬件设备驱动功能
- 提供系统调用接口



## 进程管理

在内核中，进程相关的“数据结构”是`task_struct`，每个进程有且只有一个`task_struct`

写时拷贝：父进程调用`fork()`，子进程复制一个`task_struct`，==如果只读，父子进程共享数据区；如果有写的操作，哪个进程进行写，就让哪个进程复制一块数据区进行写操作==



**进程是如何切换的？**

CPU调度器中有一系列寄存器，每个进程保存了寄存器值

当前进程（current）切换到下一个进程（next）：在当前进程上下文中保存当前的寄存器值，然后加载下一个进程上下文中的寄存器值，完成进程切换



**进程的就绪队列**

就绪队列是一个集合，其数据结构可以是数组、链表、队列或**红黑树**

使用vruntime作为key来实现红黑树

## 内存管理

进程在运行时，是需要不断分配（malloc）若干个内存空间的

**如何表示一块碎片内存？**

开始位置和结束位置确定一块内存

使用红黑树进行内存管理时，内存块的开始位置作为节点的key，内存块作为value



# epoll实现原理

epoll是用来管理fd（socket也是fd）的，其数据结构是红黑树

```c++
int epfd = epoll_create();
```

在内核中创建一个文件描述符，这个文件描述符指向一个红黑树

每个结点的key是sockfd，value是epoll_event（events，data）

当监听到事件发生时，内核把对应的节点放入到**就绪队列**中，并通知`epoll_wait()`从就绪队列中获取这些节点，复制到用户空间定义的epoll_event结构体数组中



**内核如何知道IO有数据，即如何监听到事件发生变化了？**



**水平触发和边沿触发是如何实现的？**



**epoll是不是线程安全？**


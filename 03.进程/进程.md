# 1 进程标识符（进程号） PID

`pid` 的数据类型是 `pid_t`，有符号的，16位整型数

查看进程的命令：`ps`

常用命令组合：

- `ps axf`：查看所有进程的信息
- `ps axm`：查看所有进程的详细信息
- `ps ax -L`



进程号是顺次向下使用的



**常用函数：**

`pid_t getpid(void)`：获得当前进程号

`pid_t getppid(void)`：获得当前进程的父进程号



# 2 进程的产生 fork()

`pid_t fork(void)`

**复制（duplicating）**一个进程，产生一个子进程，子进程的状态和父进程的状态==基本一样（父子进程都停留在fork语句，fork语句之后执行的操作一模一样）==，但有以下偏差：

- 父子进程使用的fork的返回值不一样
- 父子进程的pid不同
- 父子进程的ppid不同
- 子进程的未决信号和文件锁不继承
- 子进程的资源利用量归零



fork之后，在父进程调用的fork，返回的是子进程号pid；在子进程调用的fork，成功创建返回0；失败返回-1



**注意点：**

- ==父进程和子进程的运行顺序是由调度器的调度策略来决定的==

- ==在fork之前，一定要使用`fflush(NULL)`刷新流==
- ==进程结束后，要调用`exit`退出进程==



## 2.1 init 进程

init进程是系统启动时最开始的一个进程

init进程的pid=1

init进程是所有进程的祖先进程



## 2.2 vfork()

vfork()复制的子进程，与父进程共享数据区

fork()复制的子进程，当进程中有对数据的操作时，使用的是**写时拷贝技术**：如果只读，父子进程共享数据区；如果有写的操作，哪个进程进行写，就让哪个进程复制一块数据区进行写操作



# 3 进程的消亡及释放资源 wait()

父进程与子进程的关系：子进程附属于父进程，相当于是父进程申请的资源

==谁申请谁释放==

因此，对于父进程而言，使用fork产生子进程后，还要释放子进程（简称，收尸）

如果不释放子进程，子进程就会占用进程号pid，成为一个“Zombie”（僵尸态）

Z态的进程是一个常见的现象



**简单来说，当父进程fork一个子进程后，需要根据子进程的结束（exit）状态，再调用释放子进程资源的函数进行”收尸“**



**常用以下三个函数“收尸”：**

    pid_t wait(int *wstatus);
    
    pid_t waitpid(pid_t pid, int *wstatus, int options);
    
    int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);



# 4 exec函数族

**注意：**在exec之前使用`fflush(NULL)`刷新流

功能：用一个新的进程替换（取代）当前进程（PID不变）

```c
int execl(const char *pathname, const char *arg, .../* (char  *) NULL */);

int execlp(const char *file, const char *arg, .../* (char  *) NULL */);

int execle(const char *pathname, const char *arg, .../*, (char *) NULL, char *const envp[] */);

int execv(const char *pathname, char *const argv[]);

int execvp(const char *file, char *const argv[]);
```





# 5 ==few：fork + exec + wait==

==exec的用法：==

如果没有使用exec，父进程和子进程是写在同一个文件中的，代码编写会冗杂



在父进程**fork**一个子进程，在子进程的作用域中，调用**exec**函数执行一个子进程的代码文件，等待子进程执行完毕后，再使用**wait**进行收尸体



> 示例：few.c
>
> 子进程执行命令行：date +%s 
>
> /bin/date是date命令所执行的二进制文件，执行这个文件就是打开一个进程
>
> ./few是父进程，fork了一个子进程（也是./few），同时等待（wait）子进程结束
>
> 但是此时的子进程执行的是另外一个进程（/bin/date）

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/wait.h>

int main()
{
    puts("Begin!");
    fflush(NULL);
    int pid = fork();

    if (pid < 0)
    {
        perror("fork()");
        exit(1);    /* code */
    }
    if(pid == 0)
    {
        execl("/bin/date", "date", "+%s", NULL);
        perror("execl()");
        exit(1);
    }
    wait(NULL);

    puts("End!");
    exit(0);
}
```



同理，对于shell而言，打开shell，执行的是`/bin/bash`二进制文件，创建了一个父进程

在shell中一旦输入了一个命令，shell就fork了一个子进程（也是shell），并等待（wait）命令结束

但是此时这个子进程执行（exec）的是命令行的二进制文件

==实例：简单的shell实现，myshell.c==



# 5 用户权限及组权限

uid在系统中保存了三份，分别是：real uid，effective uid（用于鉴定权限）， save uid（可以没有）

gid与uid情况类似



## 5.1 u+s \ g+s 权限

文件权限一般情况下是rwx

某些特殊文件，如passwd命令行的二进制文件，x权限的位置变为了s

这个文件就具有u+s权限

u+s权限：如果一个文件有u+s权限，那么当某个用户调用这个文件时，这个用户会切换到这个文件所有者的身份来执行

g+s权限同理



例如：

命令行passwd的二进制文件的所有者是root，uid为0 0 0，具有u+s权限

当前用户（假设uid为2 2 2）执行命令passwd后，因为passwd具有u+s权限，所以用户会切换到这个文件的所有者，也就是root用户的身份来执行，那么当前用户此时的uid变成了**2 0 0**

2是真实用户的real uid；0是root用户的uid（也就是当前的effctive uid）

相当于给当前用户赋予了其他用户的权限

==也就是说，一个用户是否可以执行某个文件，关键是看这个用户的effective uid是否可执行==



## 5.2 常用函数

`uid_t getuid()`：返回real uid

`uid_t geteuid()`：返回effetcitve uid

`int setuid()`：设置real uid

`int seteuid()`：设置effective uid

`int setreuid(uid_t ruid, uid_t euid)`：交换ruid和euid



`gid_t getgid()`：返回real gid

`gid_t getegid()`：返回effective gid

`int setgid`：设置effective gid

`int setegid()`：设置effective gid

`int setregid(uid_t rgid, uid_t egid)`：交换real gid和effective gid



# 解释器文件



# system()



# 进程会计



# 进程时间



# 守护进程



# 系统日志
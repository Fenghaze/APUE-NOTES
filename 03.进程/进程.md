# 1 进程标识符（进程号） PID

`pid` 的数据类型是 `pid_t`，有符号的，16位整型数

查看进程的命令：`ps`

常用命令组合：

- `ps axf`：查看所有进程的信息
- `ps axm`：查看所有进程的详细信息
- `ps ax -L`



进程号是顺次向下使用的



**常用函数：**

`pid_t getpid(void)`：获得当前进程号

`pid_t getppid(void)`：获得当前进程的父进程号



# 2 进程的产生 fork()

`pid_t fork(void)`

**复制（duplicating）**一个进程，产生一个子进程，子进程的状态和父进程的状态==基本一样（父子进程都停留在fork语句，fork语句之后执行的操作一模一样）==，但有以下偏差：

- 父子进程使用的fork的返回值不一样
- 父子进程的pid不同
- 父子进程的ppid不同
- 子进程的未决信号和文件锁不继承
- 子进程的资源利用量归零



fork之后，在父进程调用的fork，返回的是子进程号pid；在子进程调用的fork，成功创建返回0；失败返回-1



**注意点：**

- ==父进程和子进程的运行顺序是由调度器的调度策略来决定的==

- ==在fork之前，一定要使用`fflush(NULL)`刷新流==
- ==进程结束后，要调用`exit`退出进程==



## 2.1 init 进程

init进程是系统启动时最开始的一个进程

init进程的pid=1

init进程是所有进程的祖先进程



## 2.2 vfork()

vfork()复制的子进程，与父进程共享数据区

fork()复制的子进程，当进程中有对数据的操作时，使用的是**写时拷贝技术**：如果只读，父子进程共享数据区；如果有写的操作，哪个进程进行写，就让哪个进程复制一块数据区进行写操作



# 3 进程的消亡及释放资源 wait()

父进程与子进程的关系：子进程附属于父进程，相当于是父进程申请的资源

==谁申请谁释放==

因此，对于父进程而言，使用fork产生子进程后，还要释放子进程（简称，收尸）

如果不释放子进程，子进程就会占用进程号pid，成为一个“Zombie”（僵尸态）

Z态的进程是一个常见的现象



**简单来说，当父进程fork一个子进程后，需要根据子进程的结束（exit）状态，再调用释放子进程资源的函数进行”收尸“**



**常用以下三个函数“收尸”：**

    pid_t wait(int *wstatus);
    
    pid_t waitpid(pid_t pid, int *wstatus, int options);
    
    int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);


# 4 exec函数族





# 5 用户权限及组权限



# 解释器文件



# system()



# 进程会计



# 进程时间



# 守护进程



# 系统日志
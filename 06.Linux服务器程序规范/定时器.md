# 1 定时器介绍

定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处理的原动力。

**Linux提供了三种定时方法：**

- socket选项SO_RCVTIMEO和SO_SNDTIMEO
- SIGALRM信号
- I/O复用系统调用的超时参数



定时事件：比如定期检测一个客户连接的活动状态

服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响

将定时事件使用某种容器类数据结构进行封装后，称为定时器

将所有定时器串联起来，以实现对定时事件的统一管理，**管理这些定时事件的容器称为定时器容器**

**常用的高效定时器管理容器：**

- 升序链表
- 时间轮
- 时间堆



# 2 Linux 定时方法

## 2.1 设置socket选项

socket选项中：SO_RCVTIMEO（接收数据超时时间）、SO_SNDTIMEO（发送数据超时时间）

**仅对与数据接收和发送相关的系统调用（send、sendmsg、recv、recvmsg、accept、connect）有效**，其中accept对应SO_RCVTIMEO选项，connect对应SO_SNDTIMEO选项

根据上述系统调用的返回值以及errno来判断超时时间是否已到，进而决定是否开始处理定时任务

```c++
struct timeval timeout;
timeout.tv_sec = time;
timeout.tv_usec = 0;
socklen_t len = sizeof(timeout);
//设置socket选项
ret = setsockopt(cfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, len);

//发送connect请求
ret = connect(cfd, (struct sockaddr *)&raddr, sizeof(raddr));
if(ret == -1)
{
    /*超时对应的错误号是EINPROGRESS。下面这个条件如果成立，我们就可以处理定时任务了*/
    if (errno == EINPROGRESS)
    {
        //处理定时器任务
        printf("connecting timeout,process timeout logic\n");
        return-1;
    }
    printf("error occur when connecting to server\n");
    return-1;
}
```



## 2.2 SIGALRAM信号

alarm或setitimer函数设置的实时闹钟一旦超时，就会触发SIGALRM信号，之后我们可以利用该信号的信号处理函数来处理定时任务。

但是，如果要处理多个定时任务，我们就需要不断地触发SIGALRM信号，并在其信号处理函数中执行到期的任务。

一般而言，SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设置的定时周期T保持不变。

如果某个定时任务的超时时间不是T的整数倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周期T反映了定时的精度。



## 2.3 IO复用设置超时参数





# 3 定时器容器

定时器通常至少要包含两个成员：一个超时时间（相对时间或者绝对时间）和一个任务回调函数。

有的时候还可能包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。

## 3.1 升序链表

如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含指向下一个定时器的指针成员。

进一步，如果链表是双向的，则每个定时器还需要包含指向前一个定时器的指针成员。

升序定时器链表：将其中的定时器按照超时时间做升序排序

> listClock.h

```c++
/**
 * @author: fenghaze
 * @date: 2021/05/22 14:42
 * @desc: 升序链表定时器容器
 * 添加定时器的时间复杂度是O(n)
 * 删除定时器的时间复杂度是O(1)
 * 执行定时任务的时间复杂度是O(1)
 */

#ifndef LISTCLOCK_H
#define LISTCLOCK_H

#include <time.h>
#define BUFFERSIZE 64

class UtilTimer;

//用户数据类型
class ClientData
{
    struct sockaddr_in addr;
    int cfd;
    char buf[BUFFERSIZE];
    UtilTimer timer;
};

//定时器类型（升序链表中的每一个元素）
class UtilTimer
{
public:
    UtilTimer() : prev(nullptr), next(nullptr) {}

public:
    time_t expire;                  //任务的超时时间，使用绝对时间
    void (*callback)(ClientData *); //回调函数处理的客户数据，由定时器的执行者传递给回调函数
    ClientData *client_data;
    UtilTimer *prev; //指向前一个定时器
    UtilTimer *next; //指向后一个定时器
};

//升序的双向链表定时器容器：初始化链表、销毁链表、插入节点、修改节点、删除节点
class ListClock
{
public:
    //初始化双向链表
    ListClock() : head(nullptr), tail(nullptr) {}

    //销毁链表：删除所有节点
    ~ListClock()
    {
        auto tmp = head;
        while (tmp)
        {
            head = tmp->next;
            delete tmp;
            tmp = head;
        }
    }

    //插入节点：头插法，向链表中添加一个定时器
    void addClock(UtilTimer *timer)
    {
        if (!timer)
        {
            return;
        }

        //头节点为空
        if (!head)
        {
            head = timer;
            return;
        }
        //头插法：升序链表
        if (timer->expire < head->expire)
        {
            timer->next = head;
            head->prev = time;
            head = timer;
            return;
        }
        //其他情况
        addClock(timer, head);
    }

    //修改指定节点：根据定时器的expire值，调整节点位置
    void adjustClock(UtilTimer *timer)
    {
        if (!timer)
        {
            return;
        }
        auto tmp = timer->next;
        //timer在末尾 或 timer < tmp，不用调整
        if (!tmp || timer->expire < tmp->expire)
        {
            return;
        }

        //timer是头节点，则重新插入
        if(timer == head)
        {
            head = head->next;
            head->prev = nullptr;
            timer->next = nullptr;
            addClock(timer, head);
        }
        //不是头节点，则删除该节点，并重新插入
        else
        {
            timer->prev->next = tmp;
            tmp->prev = timer->prev;
            addClock(timer, tmp);
        }
    }

    //删除指定节点
    void delClock(UtilTimer *timer)
    {
        if(!timer) 
        {
            return;
        }
        //链表中只有一个定时器(链表长度为1)
        if((timer==head) && (timer==tail))
        {
            delete timer;
            head = nullptr;
            tail = nullptr;
            return;
        }

        //链表中至少有两个定时器，且timer==head
        if (timer == head)
        {
            head = head->next;
            head->prev = nullptr;
            delete timer;
            return;
        }

        //链表中至少有两个定时器，且timer==tail
        if(timer == tail)
        {
            tail = tail->prev;
            tail->next = nullptr;
            delete timer;
            return;
        }

        //timer不是head、tail
        timer->next->prev = timer->perv;
        timer->prev->next = timer->next;
        delete timer;
    }

    //处理定时事件：每隔一段事件调用一次来处理定时事件
    void tick()
    {
        if (!head)
        {
            return;
        }
        printf("timer tick\n");
        time_t cur = time(nullptr); //当前时间
        UtilTimer *tmp = head;
        while (tmp)
        {
            if(cur < tmp->expire)   //还没有达到处理时间，break，等待下一次调用tick()
            {
                break;
            }
            
            //执行回调函数，处理客户数据
            tmp->callback(tmp->client_data);
            
            //处理完一个定时器就删掉
            head = tmp->next;
            if (head)
            {
                head->prev = nullptr;
            }
            delete tmp;
            tmp = head;
        }
    }

private:
    //表示将目标定时器timer添加到节点lst_head之后的部分链表中  
    void addClock(UtilTimer *timer, UtilTimer *lst_head)
    {
        auto tmp = lst_head->next;
        auto pre = lst_head;
        while (tmp)
        {
            if(timer->expire < tmp->expire)
            {
                pre->next = timer;
                timer->next = tmp;
                timer->prev = pre;
                tmp->prev = timer;
                break;
            }
            pre = tmp;
            tmp = tmp->next;
        }
        //如果tmp < timer，则插入到末尾
        if(!tmp)
        {
            pre->next = timer;
            timer->prev = pre;
            timer->next = nullptr;
            tail = timer;
        }
    }

private:
    UtilTimer *head;	//头结点
    UtilTimer *tail;	//尾结点
};

#endif // LISTCLOCK_H
```





## 3.2 时间轮



## 3.3 时间堆



